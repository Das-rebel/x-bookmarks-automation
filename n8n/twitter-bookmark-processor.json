{
  "name": "Twitter Bookmark Processor",
  "nodes": [
    {
      "parameters": {},
      "id": "execute-trigger-001",
      "name": "Execute Workflow Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1,
      "position": [
        -2600,
        400
      ]
    },
    {
      "parameters": {
        "url": "http://localhost:3000/scrape",
        "requestMethod": "POST",
        "jsonParameters": true,
        "options": {
          "bodyContentType": "json",
          "timeout": 60000,
          "ignoreHttpStatusErrors": true
        },
        "bodyParametersJson": "{\n  \"auth_token\": \"ec755b44cd487e95ee76d9c3ecfb8ef14b19a140\",\n  \"user_id\": \"dasrebel\"\n}",
        "sendBody": true,
        "specifyBody": "json"
      },
      "id": "92c566a0-a494-4d51-a02d-ad49d16563fa",
      "name": "Bookmark Fetch (Primary)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        -2380,
        180
      ],
      "retryOnFail": true,
      "maxTries": 3,
      "retryInterval": 15000
    },
    {
      "parameters": {
        "url": "https://api.scrapingbee.com/v1/",
        "requestMethod": "GET",
        "options": {
          "ignoreHttpStatusErrors": true,
          "timeout": 60000
        },
        "queryParametersUi": {
          "parameter": [
            {
              "name": "api_key",
              "value": "={{ $env.SCRAPINGBEE_KEY }}"
            },
            {
              "name": "url",
              "value": "https://twitter.com/i/bookmarks"
            },
            {
              "name": "render_js",
              "value": "true"
            },
            {
              "name": "wait",
              "value": "8000"
            },
            {
              "name": "extract_rules",
              "value": "{\"bookmarks\":{\"selector\":\"article\",\"type\":\"list\",\"output\":{\"text\":{\"selector\":\"[data-testid=tweetText]\",\"output\":\"text\"},\"author\":{\"selector\":\"[data-testid=User-Name]\",\"output\":\"text\"},\"url\":{\"selector\":\"a[href*=status]\",\"output\":\"href\"},\"timestamp\":{\"selector\":\"time\",\"output\":\"datetime\"}}}}"
            }
          ]
        }
      },
      "id": "b3d4a5b6-c7d8-4e9f-af01-23456789abcd",
      "name": "Bookmark Fetch (Fallback)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        -2380,
        320
      ],
      "retryOnFail": true,
      "maxTries": 2
    },
    {
      "parameters": {
        "jsCode": "const primaryResponse = $input.all()[0].json;\nconst fallbackResponse = $input.all()[1]?.json;\n\n// Check if primary response is valid\nif (primaryResponse && primaryResponse.bookmarks && !primaryResponse.error) {\n  return [{\n    json: {\n      ...primaryResponse,\n      source: 'primary'\n    }\n  }];\n}\n\n// Check if fallback response is valid\nif (fallbackResponse && fallbackResponse.bookmarks) {\n  return [{\n    json: {\n      bookmarks: fallbackResponse.bookmarks,\n      source: 'fallback'\n    }\n  }];\n}\n\n// All options failed\nthrow new Error('All bookmark fetch methods failed');"
      },
      "id": "c1d2e3f4-g5h6-7i8j-9k0l-m1n2o3p4q5r6",
      "name": "Bookmark Selector",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2160,
        240
      ]
    },
    {
      "parameters": {
        "jsCode": "const bookmark = $json;\nconst media = {\n  has_images: false,\n  has_video: false,\n  is_thread: false,\n  youtube_links: []\n};\n\n// Detect media types\nif (bookmark.text) {\n  // Image detection\n  media.has_images = /pic\\.twitter\\.com|twitter\\.com\\/[^\\/]+\\/status\\/[0-9]+\\/photo\\//i.test(bookmark.text) || \n                  (bookmark.media_urls && bookmark.media_urls.length > 0);\n  \n  // Video detection\n  media.has_video = /video|gif|mp4|mov/i.test(bookmark.text);\n  \n  // YouTube detection\n  media.youtube_links = (bookmark.text.match(/(https?:\\/\\/)?(www\\.)?(youtube\\.com|youtu\\.be)\\/[^\\s]+/gi) || []);\n}\n\n// Thread detection\nmedia.is_thread = /(thread|\\d+\\/\\d+|üßµ|üëâ)/i.test(bookmark.text);\n\nreturn [\n  {\n    json: {\n      ...bookmark,\n      media_info: media\n    }\n  }\n];"
      },
      "id": "950622d7-cc0c-454d-825e-0fd0149f095e",
      "name": "Media Detector",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1940,
        240
      ]
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "https://api-inference.huggingface.co/models/google/vit-base-patch16-224",
        "options": {
          "fullResponse": false,
          "ignoreHttpStatusErrors": true,
          "timeout": 30000
        },
        "headerParametersUi": {
          "parameter": [
            {
              "name": "Authorization",
              "value": "Bearer {{ $env.HF_API_KEY }}"
            }
          ]
        }
      },
      "id": "57db4766-1a90-4c84-a95d-e0749af25530",
      "name": "Image Classifier",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        -1720,
        40
      ],
      "retryOnFail": true,
      "maxTries": 3
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "https://api-inference.huggingface.co/models/microsoft/resnet-50",
        "options": {
          "fullResponse": false,
          "ignoreHttpStatusErrors": true,
          "timeout": 30000
        },
        "headerParametersUi": {
          "parameter": [
            {
              "name": "Authorization",
              "value": "Bearer {{ $env.HF_API_KEY }}"
            }
          ]
        }
      },
      "id": "dc664319-9024-4c43-b245-951031b01eee",
      "name": "Meme/Infographic Check",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        -1720,
        240
      ],  
      "retryOnFail": true,
      "maxTries": 3
    },
    {
      "parameters": {
        "jsCode": "const bookmark = $json;\n\nif (!bookmark.media_info.is_thread) {\n  return { json: bookmark };\n}\n\ntry {\n  // Alternative thread processing\n  const response = await $fetch(bookmark.url, { timeout: 30000 });\n  \n  // Simple DOM parsing for thread content\n  const threadMatches = response.match(/<div[^>]+data-testid=\"tweetText\"[^>]*>(.*?)<\\/div>/gis) || [];\n  const threadTexts = [];\n  \n  for (const match of threadMatches) {\n    const textMatch = match.match(/>([^<]*)</);\n    if (textMatch && textMatch[1]) {\n      threadTexts.push(textMatch[1].trim());\n    }\n  }\n  \n  const fullThread = threadTexts.join('\\n\\n');\n  \n  if (!fullThread) return { json: bookmark };\n  \n  // Summarize with AI\n  const prompt = `Summarize this Twitter thread in 50 words or less:\\n\\n${fullThread}\\n\\nSummary:`;\n  \n  const aiResponse = await $fetch('https://api.openai.com/v1/chat/completions', {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${$env.OPENAI_API_KEY}`,\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      model: 'gpt-3.5-turbo',\n      messages: [{ role: 'user', content: prompt }],\n      max_tokens: 100,\n      temperature: 0.2\n    }),\n    timeout: 30000\n  });\n  \n  const summary = aiResponse.choices?.[0]?.message?.content?.trim() || 'Thread summary unavailable';\n  \n  return { json: { ...bookmark, thread_summary: summary } };\n} catch (error) {\n  console.error('Thread processing failed:', error);\n  return { json: { ...bookmark, thread_error: error.message } };\n}"
    },
    "id": "9c430f4e-8c5f-4fe2-96cb-bef2fc7fab19",
    "name": "Thread Processor",
    "type": "n8n-nodes-base.code",
    "typeVersion": 2,
    "position": [
      -1720,
      640
    ]
  },
  {
      "parameters": { "jsCode": "const bookmark = $json;\n\nif (!bookmark.media_info.has_images) {\n  return { json: bookmark };\n}\n\nconst MAX_REQUESTS_PER_MINUTE = 10;\nconst delay = 60000 / MAX_REQUESTS_PER_MINUTE;\n\nconst processedBookmark = { ...bookmark, image_captions: [] };\n\nfor (const imageUrl of bookmark.media_urls) {\n  try {\n    await new Promise(resolve => setTimeout(resolve, 600)); // Rate limit\n    \n    const response = await $fetch('https://api-inference.huggingface.co/models/Salesforce/blip-image-captioning-base', {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${$env.HF_API_KEY}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ inputs: imageUrl }),\n      timeout: 30000\n    });\n    \n    if (Array.isArray(response) && response[0]?.generated_text) {\n      processedBookmark.image_captions.push(response[0].generated_text);\n    }\n  } catch (error) {\n    console.error(`Image captioning failed for ${imageUrl}:`, error);\n    processedBookmark.image_captions.push('Caption unavailable');\n  }\n}\n\nreturn { json: processedBookmark };"
      },
      "id": "44388737-e38c-4dfd-b87f-e2ce051bf846",
      "name": "Image Captioning",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1720,
        -160
      ]
    },
    {
      "parameters": {
        "jsCode": "const bookmark = $input.all()[0].json;\n\n// Normalize bookmark data\nconst normalizedBookmark = {\n  id: bookmark.id || Date.now().toString(),\n  text: bookmark.text || '',\n  author: bookmark.author || 'unknown',\n  created_at: bookmark.timestamp || new Date().toISOString(),\n  url: bookmark.url || '',\n  media_urls: bookmark.media_urls || [],\n  media_info: bookmark.media_info || {},\n  image_tags: bookmark.image_tags || [],\n  meme_tags: bookmark.meme_tags || [],\n  youtube_metadata: bookmark.youtube_metadata || null,\n  image_captions: bookmark.image_captions || [],\n  thread_summary: bookmark.thread_summary || null\n};\n\nfunction extractBookmarkFeatures(bookmarkData) {\n  const text = bookmarkData.text;\n  const createdAt = new Date(bookmarkData.created_at);\n  const emojiPattern = /[\\uD83C-\\uDBFF\\uDC00-\\uDFFF]+/g;\n  \n  return {\n    hashtag_count: (text.match(/#\\w+/g) || []).length,\n    mention_count: (text.match(/@\\w+/g) || []).length,\n    url_count: (text.match(/https?:\\/\\/[^\\s]+/g) || []).length,\n    emoji_count: (text.match(emojiPattern) || []).length,\n    exclamation_count: (text.match(/!/g) || []).length,\n    question_count: (text.match(/\\?/g) || []).length,\n    caps_ratio: text.replace(/[^A-Z]/g, '').length / Math.max(text.length, 1),\n    word_count: text.split(/\\s+/).length,\n    char_count: text.length,\n    hour_of_day: createdAt.getHours(),\n    day_of_week: createdAt.getDay(),\n    is_reply: text.startsWith('@'),\n    is_retweet: text.startsWith('RT @'),\n    thread_indicators: (text.match(/\\b\\d+\\/\\d+\\b|thread|üßµ/gi) || []).length > 0,\n    hashtags: (text.match(/#\\w+/g) || []).map(tag => tag.substring(1)),\n    mentions: (text.match(/@\\w+/g) || []).map(handle => handle.substring(1)),\n    urls: text.match(/https?:\\/\\/[^\\s]+/g) || []\n  };\n}\n\nfunction calculateEngagementPotential(features) {\n  let score = 0.5;\n  score += Math.min(0.2, features.hashtag_count * 0.05);\n  score += Math.min(0.1, features.mention_count * 0.03);\n  score += features.question_count * 0.1;\n  score += Math.min(0.15, features.emoji_count * 0.03);\n  score -= features.url_count * 0.05;\n  if (features.word_count >= 10 && features.word_count <= 30) score += 0.1;\n  if (features.hour_of_day >= 9 && features.hour_of_day <= 17) score += 0.05;\n  return Math.max(0, Math.min(1, score));\n}\n\nfunction calculateReadability(text) {\n  const sentences = text.split(/[.!?]+/).length;\n  const words = text.split(/\\s+/).length;\n  const avgWordsPerSentence = words / Math.max(sentences, 1);\n  const avgCharsPerWord = text.length / Math.max(words, 1);\n  const complexity = (avgWordsPerSentence / 20) + (avgCharsPerWord / 10);\n  return Math.max(0, Math.min(1, 1 - complexity));\n}\n\nconst bookmarkFeatures = extractBookmarkFeatures(normalizedBookmark);\n\n// Add media features\nconst mediaFeatures = {\n  has_media: normalizedBookmark.media_urls.length > 0,\n  image_count: normalizedBookmark.media_urls.length,\n  is_thread: normalizedBookmark.media_info.is_thread || false,\n  youtube_video: !!normalizedBookmark.youtube_metadata,\n  meme_score: 0,\n  infographic_score: 0\n};\n\n// Process image analysis results\nif (normalizedBookmark.image_tags.length > 0) {\n  mediaFeatures.image_tags = normalizedBookmark.image_tags.map(tag => tag.label || tag);\n  \n  // Calculate meme/infographic probability\n  const memeKeywords = ['meme', 'funny', 'humor', 'comic'];\n  const infographicKeywords = ['infographic', 'chart', 'graph', 'data'];\n  \n  mediaFeatures.meme_score = normalizedBookmark.image_tags.reduce((score, tag) => {\n    const label = (tag.label || tag).toLowerCase();\n    return memeKeywords.some(kw => label.includes(kw)) ? \n      score + (tag.score || 0.5) : score;\n  }, 0);\n  \n  mediaFeatures.infographic_score = normalizedBookmark.image_tags.reduce((score, tag) => {\n    const label = (tag.label || tag).toLowerCase();\n    return infographicKeywords.some(kw => label.includes(kw)) ? \n      score + (tag.score || 0.5) : score;\n  }, 0);\n}\n\nconst enhancedBookmark = {\n  ...normalizedBookmark,\n  engagement_score: 0,\n  processed_at: new Date().toISOString(),\n  bookmark_features: bookmarkFeatures,\n  media_features: mediaFeatures,\n  engagement_potential: calculateEngagementPotential(bookmarkFeatures),\n  readability_score: calculateReadability(normalizedBookmark.text),\n  positive_indicators: (normalizedBookmark.text.match(/\\b(great|amazing|awesome|love|excellent|fantastic|wonderful|brilliant|perfect|outstanding)\\b/gi) || []).length,\n  negative_indicators: (normalizedBookmark.text.match(/\\b(terrible|awful|hate|horrible|worst|disgusting|pathetic|useless|stupid|annoying)\\b/gi) || []).length,\n  tech_indicators: (normalizedBookmark.text.match(/\\b(AI|ML|tech|startup|code|programming|software|app|digital|innovation|algorithm|data|cloud|blockchain|crypto)\\b/gi) || []).length,\n  business_indicators: (normalizedBookmark.text.match(/\\b(business|marketing|sales|revenue|profit|growth|strategy|leadership|management|entrepreneur|investment|funding)\\b/gi) || []).length\n};\n\nreturn { json: enhancedBookmark };"
      },
      "id": "81c64983-2df4-4fad-b1ea-3efd72c3c335",
      "name": "Enhanced Preprocess",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1500,
        240
      ]
    },
    {
      "parameters": {
        "jsCode": "const bookmarkData = $input.all()[0].json;\nconst maxRetries = 3;\nconst baseDelay = 30000;\n\nconst providers = [\n  {\n    name: 'OpenAI',\n    url: 'https://api.openai.com/v1/chat/completions',\n    apiKey: $env.OPENAI_API_KEY,\n    model: 'gpt-4-turbo',\n    maxTokens: 500,\n    temperature: 0.2,\n    maxRPM: 60\n  },\n  {\n    name: 'DeepSeek',\n    url: 'https://api.deepseek.com/v1/chat/completions',\n    apiKey: $env.DEEPSEEK_API_KEY,\n    model: 'deepseek-chat',\n    maxTokens: 500,\n    temperature: 0.2,\n    maxRPM: 120\n  }\n];\n\nconst rateLimits = {};\n\nfunction currentTimestamp() {\n  return Math.floor(Date.now() / 1000);\n}\n\nfunction canRequest(provider) {\n  if (!rateLimits[provider.name]) {\n    rateLimits[provider.name] = {\n      lastRequest: 0,\n      requestCount: 0,\n      resetTime: 0\n    };\n    return true;\n  }\n  \n  const now = currentTimestamp();\n  const limit = rateLimits[provider.name];\n  \n  if (now >= limit.resetTime) {\n    limit.requestCount = 0;\n    limit.resetTime = now + 60;\n  }\n  \n  return limit.requestCount < provider.maxRPM;\n}\n\nfunction updateRateLimit(provider) {\n  if (!rateLimits[provider.name]) {\n    rateLimits[provider.name] = {\n      lastRequest: currentTimestamp(),\n      requestCount: 1,\n      resetTime: currentTimestamp() + 60\n    };\n  } else {\n    const limit = rateLimits[provider.name];\n    limit.requestCount++;\n    limit.lastRequest = currentTimestamp();\n  }\n}\n\n// Bookmark-specific prompt\nconst mediaContext = [];\n\nif (bookmarkData.image_captions.length > 0) {\n  mediaContext.push(`Image captions: ${bookmarkData.image_captions.join('; ')}`);\n}\n\nif (bookmarkData.youtube_metadata) {\n  mediaContext.push(`YouTube video: ${bookmarkData.youtube_metadata.title}`);\n}\n\nif (bookmarkData.thread_summary) {\n  mediaContext.push(`Thread summary: ${bookmarkData.thread_summary}`);\n}\n\nconst mediaPrefix = mediaContext.length > 0 ? \n  `Media Context:\\n${mediaContext.join('\\n')}\\n\\n` : '';\n\nconst prompt = `${mediaPrefix}Analyze this saved Twitter bookmark in JSON format. Include:\\n1. Bookmark reason (max 100 chars)\\n2. Knowledge tags (max 8)\\n3. Key entities (people/orgs/products, max 15)\\n4. Core concepts (max 10)\\n5. Sentiment {label, confidence}\\n6. Content type (article, tutorial, news, opinion, humor)\\n7. Relevance score (0-1)\\n8. Value score (0-1)\\n9. Actionable (boolean)\\n10. Categories (max 5)\\n11. Quality score (0-1)\\n12. Key insights (max 5)\\n13. Reference worthy (boolean)\\n\\nBookmark data:\\n${JSON.stringify(bookmarkData)}\\n\\nOutput ONLY valid JSON, no extra text.`;\n\nasync function callProvider(provider, retryCount = 0) {\n  try {\n    if (!canRequest(provider)) {\n      const delay = 60000;\n      await new Promise(resolve => setTimeout(resolve, delay));\n      return callProvider(provider, retryCount);\n    }\n    \n    const requestBody = {\n      model: provider.model,\n      messages: [{\n        role: 'user',\n        content: prompt\n      }],\n      max_tokens: provider.maxTokens,\n      temperature: provider.temperature,\n      response_format: { \"type\": \"json_object\" }\n    };\n    \n    const response = await $fetch(provider.url, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${provider.apiKey}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(requestBody),\n      timeout: 45000\n    });\n    \n    if (response.statusCode === 429) {\n      const resetTime = parseInt(response.headers['x-ratelimit-reset']) * 1000;\n      const waitTime = resetTime - Date.now() + 1000;\n      await new Promise(resolve => setTimeout(resolve, waitTime));\n      return callProvider(provider, retryCount + 1);\n    }\n    \n    if (response.error) {\n      throw new Error(response.error.message);\n    }\n    \n    updateRateLimit(provider);\n    \n    return {\n      provider: provider.name,\n      response: response\n    };\n  } catch (error) {\n    if (retryCount < maxRetries) {\n      const delay = baseDelay * Math.pow(2, retryCount);\n      await new Promise(resolve => setTimeout(resolve, delay));\n      return callProvider(provider, retryCount + 1);\n    }\n    throw error;\n  }\n}\n\nlet result = null;\n\nfor (const provider of providers) {\n  if (!provider.apiKey) continue;\n  \n  try {\n    result = await callProvider(provider);\n    if (result) break;\n  } catch (error) {\n    errors.push(`${provider.name}: ${error.message}`);\n  }\n}\n\nif (result) {\n  return { json: result };\n} else {\n  return { json: {\n    ai_failed: true,\n    errors: errors,\n    original_data: bookmarkData\n  }};\n}"
      },
      "id": "55b10600-c19a-4a3e-8677-d74c6187831a",
      "name": "AI Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [ -1280, 240 ]
    },
    {
      "parameters": {
        "jsCode": "const aiResponse = $input.all()[0].json;\n\nif (aiResponse.ai_failed) {\n  return { json: {\n    ai_failed: true,\n    errors: aiResponse.errors,\n    original_data: aiResponse.original_data\n  } };\n}\n\nconst provider = aiResponse.provider;\nconst response = aiResponse.response;\n\nlet analysis = {};\ntry {\n  let rawContent = '';\n  \n  if (provider === 'OpenAI' || provider === 'DeepSeek') {\n    rawContent = response.choices?.[0]?.message?.content || '';\n  }\n  \n  const cleanContent = rawContent.replace(/```json\\n?|```\\n?/g, '').trim();\n  analysis = JSON.parse(cleanContent);\n} catch (e) {\n  return { json: {\n    ai_failed: true,\n    error: `Parsing failed (${provider}): ${e.message}`,\n    original_data: response\n  } };\n}\n\nconst v = (analysisVal, def, max) => {\n  if (typeof analysisVal === 'string') return analysisVal;\n  return Array.isArray(analysisVal) ? analysisVal.slice(0, max) : def;\n};\n\nconst sentiment = (s) => typeof s === 'object' ? { \n  label: s.label || 'neutral', \n  confidence: s.confidence || 0.5 \n} : { \n  label: s || 'neutral', \n  confidence: 0.5 \n};\n\nconst validated = {\n  provider: provider,\n  reason: (analysis.reason || 'No reason extracted').substring(0, 100),\n  tags: v(analysis.tags, [], 8),\n  entities: v(analysis.entities, [], 15),\n  concepts: v(analysis.concepts, [], 10),\n  sentiment: sentiment(analysis.sentiment),\n  content_type: analysis.content_type || 'unknown',\n  relevance_score: Math.min(1, Math.max(0, Number(analysis.relevance_score) || 0.5)),\n  value_score: Math.min(1, Math.max(0, Number(analysis.value_score) || 0.5)),\n  actionable: Boolean(analysis.actionable),\n  categories: v(analysis.categories, ['uncategorized'], 5),\n  quality_score: Math.min(1, Math.max(0, Number(analysis.quality_score) || 0.5)),\n  key_insights: v(analysis.key_insights, [], 5),\n  reference_worthy: Boolean(analysis.reference_worthy)\n};\n\nvalidated.composite_score = validated.relevance_score*0.3 + validated.quality_score*0.3 + validated.value_score*0.2 + (validated.actionable?0.1:0) + (validated.reference_worthy?0.1:0);\n\nreturn { json: validated };"
      },
      "id": "b4ea736c-3a4e-458e-9aca-405723b08c9b",
      "name": "Parse AI Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [ -1060, 240 ]
    },
    {
      "parameters": {
        "jsCode": "const enhancedBookmark = $input.all()[0].json;\nconst aiAnalysis = $input.all()[1].json;\n\nreturn {\n  json: {\n    id: enhancedBookmark.id,\n    created_at: enhancedBookmark.created_at,\n    bookmark_data: enhancedBookmark,\n    ai_analysis: aiAnalysis,\n    processed_at: new Date().toISOString()\n  }\n};"
      },
      "id": "85c0c98e-4549-41b0-81e1-b7eecb795f79",
      "name": "Merge Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [ -840, 240 ]
    },
    {
      "parameters": {
        "jsCode": "const mergedData = $input.all()[0].json;\n\n// Schema validation\nconst requiredFields = ['id', 'created_at', 'bookmark_data', 'ai_analysis'];\nconst missingFields = requiredFields.filter(field => !mergedData[field]);\n\nif (missingFields.length > 0) {\n  throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\n}\n\n// Sanitize text data\nconst sanitize = (text) => text.replace(/[<>\"']/g, '');\nmergedData.bookmark_data.text = sanitize(mergedData.bookmark_data.text);\n\nreturn { json: mergedData };"
      },
      "id": "data-validator-001",
      "name": "Data Validator",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [ -720, 240 ]
    },
    {
      "parameters": { "operation": "insert" },
      "id": "64e844c6-4faa-42d2-b921-41c56d042b24",
      "name": "Save to Database",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [ -600, 240 ],
      "credentials": {
        "supabaseApi": {
          "id": "eEpDlsM6hC5TAe96",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const mergedData = $input.all()[0].json;\n\nconst safeString = (str) => (str || '').replace(/[^\\w\\s-]/g, '');\nconst safeArray = (arr) => (Array.isArray(arr) ? arr.join(', ') : '');\n\nconst knowledgeContent = `# Twitter Bookmark Knowledge Entry\n\n## Bookmark Info\nID: ${mergedData.id}\\nAuthor: ${safeString(mergedData.bookmark_data.author)}\\nDate: ${mergedData.bookmark_data.created_at}\\nURL: ${mergedData.bookmark_data.url}\\n\\n## Content\\n${safeString(mergedData.bookmark_data.text)}\\n\\n## Media Analysis\\n${\n  mergedData.bookmark_data.media_features?.has_media ? \n  `- Media type: ${mergedData.bookmark_data.media_features.has_images ? 'Image' : ''}${mergedData.bookmark_data.media_features.youtube_video ? 'YouTube' : ''}\\n` +\n  (mergedData.bookmark_data.thread_summary ? `- Thread summary: ${safeString(mergedData.bookmark_data.thread_summary)}\\n` : '') +\n  (mergedData.bookmark_data.image_captions?.length ? `- Image captions: ${safeArray(mergedData.bookmark_data.image_captions)}\\n` : '') \n  : 'No media'\n}\\n\\n## AI Analysis\\n**Provider**: ${mergedData.ai_analysis.provider}\\n**Reason**: ${safeString(mergedData.ai_analysis.reason)}\\n**Tags**: ${safeArray(mergedData.ai_analysis.tags)}\\n**Sentiment**: ${mergedData.ai_analysis.sentiment?.label || 'neutral'} (${Math.round((mergedData.ai_analysis.sentiment?.confidence || 0.5) * 100)}%)\\n\\n## Key Insights\\n- ${safeArray(mergedData.ai_analysis.key_insights) || 'None'}\\n\\n## Actionable Items\\n${mergedData.ai_analysis.actionable ? '‚úÖ Contains actionable information' : '‚ùå No actionable items'}`;\n\nreturn {\n  json: {\n    knowledge: knowledgeContent,\n    filename: `bookmark_${mergedData.id}_knowledge.md`\n  }\n};"
      },
      "id": "a65da785-027a-42a1-86be-11b6a2a9df41",
      "name": "Prepare Knowledge",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [ -400, 240 ]
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "https://api.openai.com/v1/files",
        "options": {
          "bodyContentType": "multipart-form-data",
          "ignoreHttpStatusErrors": true,
          "timeout": 60000
        },
        "bodyParametersUi": {
          "parameter": [
            {
              "name": "purpose",
              "value": "assistants"
            },
            {
              "name": "file",
              "value": "={{ { value: $json['knowledge'], property: 'file' } }}"
            },
            {
              "name": "filename",
              "value": "={{ $json['filename'] }}"
            }
          ]
        },
        "headerParametersUi": {
          "parameter": [
            {
              "name": "Authorization",
              "value": "Bearer {{ $env.OPENAI_API_KEY }}"
            }
          ]
        }
      },
      "id": "4925bf6a-0b27-4aa7-8119-2ca5c888b2b2",
      "name": "Upload to OpenAI Files",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [ -180, 240 ],
      "retryOnFail": true,
      "maxTries": 3
    }
  ],
  "pinData": {},
  "connections": {
    "Execute Workflow Trigger": {
      "main": [
        [
          {
            "node": "Bookmark Fetch (Primary)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Bookmark Fetch (Fallback)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Bookmark Fetch (Primary)": {
      "main": [
        [
          {
            "node": "Bookmark Selector",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Bookmark Fetch (Fallback)": {
      "main": [
        [
          {
            "node": "Bookmark Selector",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "...": "..."
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "9a753a1c-7cf1-49b7-92f5-d5ff03dbd0ee",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "400440da225267fcba42c3f9649794b955df71a58517c58d1db645d5521ecc4b"
  },
  "id": "5EF8w3AOgeGZgQs5",
  "tags": [
    {
      "createdAt": "2025-07-05T18:28:31.108Z",
      "updatedAt": "2025-07-05T18:28:31.108Z",
      "id": "QhJAXRpaYb0BHpEz",
      "name": "twitter-automation"
    }
  ]
}
